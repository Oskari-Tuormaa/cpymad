# This script builds cpymad windows wheels for all supported python versions
# using @carlkl's mingwpy. It must be invoked in an enviroment with the
# following dependencies:
#
# - conda (for managing environments for different python versions)
#
# - $env:PLATFORM environment variable set to either "x86" or "x64"
#
# - $env:MADXDIR environment variable with the output directory from
#          powershell -File build_madx.ps1
#
# IMPORTANT: mingwpy is the only compiler I found that links statically
# against most of the runtime libraries (except for msvcrXX.dll) and thus
# produces the most portable binaries. If porting to another compiler, please
# check the resulting `libmadx.pyd` file with "Dependency Walker"
# (http://www.dependencywalker.com/) for non-system runtime dependencies!

$ErrorActionPreference = "Stop"

$MADXDIR = if ($env:MADXDIR) { $env:MADXDIR } else { "madx-bin" }
$MADXDIR = [System.IO.Path]::Combine($(pwd), $MADXDIR)

function call()
{
    & $args[0] $args[1..$args.length]
    if (!$?) { throw "Exit code $LastExitCode from command `"$args`"." }
}

# Create python environments:
mkdir -Force envs
conda create -qy -p envs\py27 python=2.7 wheel cython
conda create -qy -p envs\py33 python=3.3 wheel cython
conda create -qy -p envs\py34 python=3.4 wheel cython
conda create -qy -p envs\py35 python=3.5 wheel cython
conda create -qy -p envs\py36 python=3.6 wheel cython
conda create -qy -p envs\py37 python=3.7 wheel cython

# Install mingwpy where available (note that mingwpy is not available on py35+
# and that the simpler installation command `conda install -n py33 mingwpy`
# fails due to a version conflict on py33):
conda activate .\envs\py27; call pip install -i https://pypi.anaconda.org/carlkl/simple mingwpy
conda activate .\envs\py33; call pip install -i https://pypi.anaconda.org/carlkl/simple mingwpy
conda activate .\envs\py34; call pip install -i https://pypi.anaconda.org/carlkl/simple mingwpy


function build_all()
{
    # Locate gcc from mingwpy in py34 (used later for Build-CpymadExtern):
    conda activate .\envs\py34
    $gcc = Get-Command gcc

    # Build cpymad wheels:
    if ($env:PLATFORM -eq "x86") {
        build_native py27
        build_native py33
        build_native py34
        build_cross py35 35 win32-3.5 cp35-win32
        build_cross py36 36 win32-3.6 cp36-win32
        build_cross py37 37 win32-3.7 cp37-win32
    } else {
        build_native py27
        build_native py33
        build_native py34
        build_cross py35 35 win-amd64-3.5 cp35-win_amd64
        build_cross py36 36 win-amd64-3.6 cp36-win_amd64
        build_cross py37 37 win-amd64-3.7 cp37-win_amd64
    }
}


# Build cpymad on py27-py34 where mingwpy is available natively. The easiest
# and most reliable way to build cpymad here is using setuptools:
function build_native($py_env)
{
    # Ensure that cython code and extension module will be rebuilt since the
    # cython code is partially incompatible between python versions:
    Remove-Item -ErrorAction Ignore src\cpymad\libmadx.c
    Remove-Item -ErrorAction Ignore src\cpymad\libmadx.pyd

    conda activate .\envs\$py_env
    call python setup.py build_ext -c mingw32 --static --madxdir=$MADXDIR
    call python setup.py bdist_wheel
}


# Build cpymad on py35+ for which mingwpy is not available. We will manually
# execute the compiler command lines that would be generated by setuptools as
# well (compare output from the `build_ext` step in :Build-CpymadNative!). The
# downside is that we link a different C runtime than is natively used by
# python. This should work as long as we don't management of C objects/memory
# between python and cpymad, and requires distributing msvcr100.dll to the
# target machine.
function build_cross($py_env, $py_ver, $dir_tag, $file_tag)
{
    # Ensure that cython code and extension module will be rebuilt since the
    # cython code is partially incompatible between python versions:
    Remove-Item -ErrorAction Ignore -Force src\cpymad\libmadx.c
    Remove-Item -ErrorAction Ignore -Force src\cpymad\libmadx.pyd

    # We use a two stage build with the exact filenames as `python setup.py
    # build_ext` would do (compile `.c` to `.obj` in %tempdir%, then link to
    # `.pyd` in %libdir%) to prevent the final `python setup.py bdist_wheel`
    # command from trying trying to perform either of these steps with MSVC.

    conda activate .\envs\$py_env
    $tempdir = "build\temp.$dir_tag\Release\src\cpymad"
    $libdir = "build\lib.$dir_tag\cpymad"
    mkdir -Force $tempdir
    mkdir -Force $libdir

    $pythondir = call python -c "import sys; print(sys.prefix)"

    # This will cythonize `.pyx` to `.c`:
    call python setup.py build_py

    call $gcc -mdll -O -Wall `
        -I$MADXDIR\include `
        -I$pythondir\include `
        -c src/cpymad/libmadx.c `
        -o $tempdir\libmadx.obj `
        -std=gnu99

    # Linking directly against the `pythonXX.dll` is the only way I found to
    # satisfy the linker in a conda python environment. The conventional
    # command line `-L%pythondir%\libs -lpython%py_ver%` used to work fine on
    # WinPython, but fails on conda with large number of complaints about
    # about undefined references, such as `__imp__Py_NoneStruct`,
    call $gcc -shared -s `
        $tempdir\libmadx.obj `
        -L$MADXDIR\lib `
        -lmadx -lptc -lgc-lib -lstdc++ -lgfortran `
        -lquadmath $pythondir\python$py_ver.dll -lmsvcr100 `
        -o $libdir\libmadx.$file_tag.pyd

    call python setup.py bdist_wheel
}

build_all
